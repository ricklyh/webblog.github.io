<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.0',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="每天进步一小点">
<meta property="og:url" content="http://mocwe.com/page/2/index.html">
<meta property="og:site_name" content="每天进步一小点">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="每天进步一小点">





  
  
  <link rel="canonical" href="http://mocwe.com/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>每天进步一小点</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/ricklyh"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/82b228a3648bf44fc1163ef44c62fcc60081495e/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f7265645f6161303030302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_red_aa0000.png"></a>
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">每天进步一小点</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">一切就是这么简单</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/08/03/cocurrent-volatile实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/08/03/cocurrent-volatile实现原理/" class="post-title-link" itemprop="url">volatile实现原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-03 23:22:04" itemprop="dateCreated datePublished" datetime="2018-08-03T23:22:04+08:00">2018-08-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-29 09:41:05" itemprop="dateModified" datetime="2019-04-29T09:41:05+08:00">2019-04-29</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/cocurrent/" itemprop="url" rel="index"><span itemprop="name">cocurrent</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Volatile含义"><a href="#Volatile含义" class="headerlink" title="Volatile含义"></a>Volatile含义</h2><ul>
<li>在Java多线程并发编程中，volatile关键词扮演着重要角色，它是轻量级的synchronized，在多处理器开发中保证了共享变量的“可见性”。“可见性”的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。如果一个字段被声明为volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。与synchronized不同，volatile变量不会引起线程上下文的切换和调度，在适合的场景下拥有更低的执行成本和更高的效率</li>
</ul>
<h2 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h2><ul>
<li>CPU缓存的出现主要是为了解决CPU运算速度与内存读写速度不匹配的矛盾，因为CPU运算速度要比内存读写速度快得多，举个例子：<ul>
<li>一次主内存的访问通常在几十到几百个时钟周期</li>
<li>一次L1高速缓存的读写只需要1~2个时钟周期</li>
<li>一次L2高速缓存的读写也只需要数十个时钟周期</li>
</ul>
</li>
<li><p>这种访问速度的显著差异，导致CPU可能会花费很长时间等待数据到来或把数据写入内存</p>
</li>
<li><p>基于此，现在CPU大多数情况下读写都不会直接访问内存（CPU都没有连接到内存的管脚），取而代之的是CPU缓存，CPU缓存是位于CPU与内存之间的临时存储器，它的容量比内存小得多但是交换速度却比内存快得多。而缓存中的数据是内存中的一小部分数据，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可先从缓存中读取，从而加快读取速度</p>
</li>
<li><p>按照读取顺序与CPU结合的紧密程度，CPU缓存可分为：</p>
<ul>
<li>一级缓存：简称L1 Cache，位于CPU内核的旁边，是与CPU结合最为紧密的CPU缓存。</li>
<li>二级缓存：简称L2 Cache，分内部和外部两种芯片，内部芯片二级缓存运行速度与主频相同，外部芯片二级缓存运行速度则只有主频的一半。</li>
<li>三级缓存：简称L3 Cache，部分高端CPU才有</li>
</ul>
</li>
<li><p>每一级缓存中所存储的数据全部都是下一级缓存中的一部分，这三种缓存的技术难度和制造成本是相对递减的，所以其容量也相对递增  </p>
</li>
<li><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有再从二级缓存中查找，如果还是没有再从三级缓存中或内存中查找。一般来说每级缓存的命中率大概都有80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取</p>
</li>
</ul>
<h2 id="CPU缓存带来的问题"><a href="#CPU缓存带来的问题" class="headerlink" title="CPU缓存带来的问题"></a>CPU缓存带来的问题</h2><ul>
<li>用一张图表示一下 CPU –&gt; CPU缓存 –&gt; 主内存 数据读取之间的关系：<br><img src="/2018/08/03/cocurrent-volatile实现原理/cpu1.png" alt="cache" title="Optional title">  </li>
<li><p>当系统运行时，CPU执行计算的过程如下：</p>
<ul>
<li>程序以及数据被加载到主内存</li>
<li>指令和数据被加载到CPU缓存</li>
<li>CPU执行指令，把结果写到高速缓存</li>
<li>高速缓存中的数据写回主内存</li>
</ul>
</li>
<li><p>如果服务器是单核CPU，那么这些步骤不会有任何的问题，但是如果服务器是多核CPU，那么问题来了，以Intel Core i7处理器的高速缓存概念模型为例（图片来自《深入理解计算机系<br><img src="/2018/08/03/cocurrent-volatile实现原理/cpu2.png" alt="cache" title="Optional title"> </p>
</li>
<li><p>试想下面一种情况：</p>
<ul>
<li>核0读取了一个字节，根据局部性原理，它相邻的字节同样被被读入核0的缓存</li>
<li>核3做了上面同样的工作，这样核0与核3的缓存拥有同样的数据</li>
<li>核0修改了那个字节，被修改后，那个字节被写回核0的缓存，但是该信息并没有写回主存</li>
<li>核3访问该字节，由于核0并未将数据写回主存，数据不同步</li>
</ul>
</li>
<li><p>为了解决这一问题，CPU制造商规定了一个缓存一致性协议</p>
</li>
</ul>
<h2 id="缓存一致性协议"><a href="#缓存一致性协议" class="headerlink" title="缓存一致性协议"></a>缓存一致性协议</h2><ul>
<li>每个CPU都有一级缓存，但是，我们却无法保证每个CPU的一级缓存数据都是一样的。 所以同一个程序，CPU进行切换的时候，切换前和切换后的数据可能会有不一致的情况。那么这个就是一个很大的问题了。 如何保证各个CPU缓存中的数据是一致的。就是CPU的缓存一致性问题</li>
</ul>
<h3 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h3><ul>
<li><p>一种处理一致性问题的办法是使用Bus Locking（总线锁）。当一个CPU对其缓存中的数据进行操作的时候，往总线中发送一个Lock信号。 这个时候，所有CPU收到这个信号之后就不操作自己缓存中的对应数据了，当操作结束，释放锁以后，所有的CPU就去内存中获取最新数据更新。</p>
</li>
<li><p>但是用锁的方式总是避不开性能问题。总线锁总是会导致CPU的性能下降。所以出现另外一种维护CPU缓存一致性的方式，MESI   </p>
</li>
</ul>
<h3 id="MESI"><a href="#MESI" class="headerlink" title="MESI"></a>MESI</h3><ul>
<li><p>MESI是保持一致性的协议。它的方法是在CPU缓存中保存一个标记位，这个标记位有四种状态:</p>
<ul>
<li>M: Modify，修改缓存，当前CPU的缓存已经被修改了，即与内存中数据已经不一致了；</li>
<li>E: Exclusive，独占缓存，当前CPU的缓存和内存中数据保持一致，而且其他处理器并没有可使用的缓存数据；</li>
<li>S: Share，共享缓存，和内存保持一致的一份拷贝，多组缓存可以同时拥有针对同一内存地址的共享缓存段；</li>
<li>I: Invalid，失效缓存，这个说明CPU中的缓存已经不能使用了</li>
</ul>
</li>
<li><p>CPU的读取遵循下面几点：</p>
<ul>
<li>如果缓存状态是I，那么就从内存中读取，否则就从缓存中直接读取。</li>
<li>如果缓存处于M或E的CPU读取到其他CPU有读操作，就把自己的缓存写入到内存中，并将自己的状态设置为S。</li>
<li>只有缓存状态是M或E的时候，CPU才可以修改缓存中的数据，修改后，缓存状态变为M</li>
</ul>
</li>
<li><p>这样，每个CPU都遵循上面的方式则CPU的效率就提高上来了</p>
</li>
</ul>
<h2 id="volatile两大作用"><a href="#volatile两大作用" class="headerlink" title="volatile两大作用"></a>volatile两大作用</h2><ul>
<li>保证内存可见性</li>
<li>防止指令重排</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/07/12/jvm-jvm调优工具说明/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/12/jvm-jvm调优工具说明/" class="post-title-link" itemprop="url">jvm调优工具说明</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-12 12:12:04" itemprop="dateCreated datePublished" datetime="2018-07-12T12:12:04+08:00">2018-07-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-22 22:38:08" itemprop="dateModified" datetime="2019-04-22T22:38:08+08:00">2019-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><ul>
<li><p>JVM配置以及调优是Java程序员进阶必须掌握的，一个优秀的Java程序员可以根据运行环境设置JVM参数，从而达到最优配置，合理充分的利用系统资源，避免生产环境发生一些如OOM的异常或者线程死锁、Java进程CPU消耗过高等问题</p>
</li>
<li><p>注意！！！：使用的jdk版本是jdk8,查看本机的初始化参数：java -XX:+PrintFlagsInitial</p>
</li>
</ul>
<h2 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h2><ul>
<li><p>JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</p>
</li>
<li><p>命令格式</p>
<ul>
<li>jps [options] [hostid]</li>
<li>option参数</li>
<li>-l : 输出主类全名或jar路径</li>
<li>-q : 只输出LVMID</li>
<li>-m : 输出JVM启动时传递给main()的参数</li>
<li>-v : 输出JVM启动时显示指定的JVM参数</li>
<li>其中[option]、[hostid]参数也可以不写</li>
</ul>
</li>
<li><p>示例  jps -ml 或 jps -l -m<br><img src="/2018/07/12/jvm-jvm调优工具说明/jps1.png" alt="jvmjps" title="Optional title">  </p>
</li>
</ul>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><ul>
<li><p>jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据    </p>
</li>
<li><p>命令格式</p>
<ul>
<li>jstat [option] LVMID [interval] [count]</li>
<li>参数</li>
<li>[option] : 操作参数</li>
<li>LVMID : 本地虚拟机进程ID</li>
<li>[interval] : 连续输出的时间间隔</li>
<li>[count] : 连续输出的次数</li>
</ul>
</li>
</ul>
<h3 id="类加载统计"><a href="#类加载统计" class="headerlink" title="类加载统计"></a>类加载统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat0.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>Loaded:加载class的数量</li>
<li>Bytes：所占用空间大小</li>
<li>Unloaded：未加载数量</li>
<li>Bytes:未加载占用空间</li>
<li>Time：时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="编译统计"><a href="#编译统计" class="headerlink" title="编译统计"></a>编译统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat1.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>Compiled：编译数量。</li>
<li>Failed：失败数量</li>
<li>Invalid：不可用数量</li>
<li>Time：时间</li>
<li>FailedType：失败类型</li>
<li>FailedMethod：失败的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="垃圾回收统计"><a href="#垃圾回收统计" class="headerlink" title="垃圾回收统计"></a>垃圾回收统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat2.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>S0C：第一个幸存区的大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>MC：方法区大小</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>YGCT：年轻代垃圾回收消耗时间</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="堆内存统计"><a href="#堆内存统计" class="headerlink" title="堆内存统计"></a>堆内存统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat3.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0C：第一个幸存区大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>EC：伊甸园区的大小</li>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代大小</li>
<li>OC:当前老年代大小</li>
<li>MCMN:最小元数据容量</li>
<li>MCMX：最大元数据容量</li>
<li>MC：当前元数据空间大小</li>
<li>CCSMN：最小压缩类空间大小</li>
<li>CCSMX：最大压缩类空间大小</li>
<li>CCSC：当前压缩类空间大小</li>
<li>YGC：年轻代gc次数</li>
<li>FGC：老年代GC次数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代垃圾回收统计"><a href="#新生代垃圾回收统计" class="headerlink" title="新生代垃圾回收统计"></a>新生代垃圾回收统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat4.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>S0C：第一个幸存区大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>TT:对象在新生代存活的次数</li>
<li>MTT:对象在新生代存活的最大次数</li>
<li>DSS:期望的幸存区大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>GCT：年轻代垃圾回收消耗时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="新生代内存统计"><a href="#新生代内存统计" class="headerlink" title="新生代内存统计"></a>新生代内存统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat5.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0CMX：最大幸存1区大小</li>
<li>S0C：当前幸存1区大小</li>
<li>S1CMX：最大幸存2区大小</li>
<li>S1C：当前幸存2区大小</li>
<li>ECMX：最大伊甸园区大小</li>
<li>EC：当前伊甸园区大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代回收次数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="老年代垃圾统计"><a href="#老年代垃圾统计" class="headerlink" title="老年代垃圾统计"></a>老年代垃圾统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat6.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>MC：方法区大小</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="老年代内存统计"><a href="#老年代内存统计" class="headerlink" title="老年代内存统计"></a>老年代内存统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat7.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代大小</li>
<li>OC：老年代大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="元数据空间统计"><a href="#元数据空间统计" class="headerlink" title="元数据空间统计"></a>元数据空间统计</h3><ul>
<li>jstat -gcmetacapacity [LVMID]</li>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat8.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>MCMN: 最小元数据容量</li>
<li>MCMX：最大元数据容量</li>
<li>MC：当前元数据空间大小</li>
<li>CCSMN：最小压缩类空间大小</li>
<li>CCSMX：最大压缩类空间大小</li>
<li>CCSC：当前压缩类空间大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结垃圾回收统计"><a href="#总结垃圾回收统计" class="headerlink" title="总结垃圾回收统计"></a>总结垃圾回收统计</h3><ul>
<li>jstat -gcutil 17063 1s 10</li>
<li>jstat -gcutil 17063 1s #一直连续输出</li>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat9.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>S0：幸存1区当前使用比例</li>
<li>S1：幸存2区当前使用比例</li>
<li>E：伊甸园区使用比例</li>
<li>O：老年代使用比例</li>
<li>M：元数据区使用比例</li>
<li>CCS：压缩使用比例</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>FGC：老年代垃圾回收次数</li>
<li>FGCT：老年代垃圾回收消耗时间</li>
<li>GCT：垃圾回收消耗总时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="JVM编译方法统计"><a href="#JVM编译方法统计" class="headerlink" title="JVM编译方法统计"></a>JVM编译方法统计</h3><ul>
<li><img src="/2018/07/12/jvm-jvm调优工具说明/jstat10.png" alt="jstat" title="Optional title"> <ul>
<li>显示字段含义<ul>
<li>Compiled：最近编译方法的数量</li>
<li>Size：最近编译方法的字节码数量</li>
<li>Type：最近编译方法的编译类型</li>
<li>Method：方法名标识</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><ul>
<li>jmap(JVM Memory Map)命令用于生成heap dump文件</li>
<li>如果不使用这个命令，还可以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件</li>
<li><p>jmap不仅能生成dump文件，还可以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等</p>
</li>
<li><p>命令格式</p>
<ul>
<li>jmap [option] LVMID</li>
<li>option参数</li>
<li>dump : 生成堆转储快照(会引发full GC)</li>
<li>finalizerinfo : 显示在F-Queue队列等待Finalizer线程执行finalizer方法的对象</li>
<li>heap : 显示Java堆详细信息</li>
<li>histo : 显示堆中对象的统计信息(会引发full GC)</li>
<li>permstat : to print permanent generation statistics</li>
<li>F : 当-dump没有响应时，强制生成dump快照</li>
</ul>
</li>
<li><p>导出整个JVM 中内存信息</p>
<ul>
<li>jmap -dump:format=b,file=文件名 [pid] ;比如：jmap -dump:format=b,file=/Users/lyh/Desktop/dumplock.hprof 20705</li>
<li>示例：jmap -histo pid 展示class的内存情况:<br><img src="/2018/07/12/jvm-jvm调优工具说明/jmap0.png" alt="jmap" title="Optional title"></li>
<li>显示字段含义<ul>
<li>instance：对象实例个数</li>
<li>bytes：总占用的字节数</li>
<li>class name:对应的就是 Class 文件里的 class 的标识</li>
<li>B 代表 byte</li>
<li>C 代表 char</li>
<li>D 代表 double</li>
<li>F 代表 float</li>
<li>I 代表 int</li>
<li>J 代表 long</li>
<li>Z 代表 boolean</li>
<li>前边有 [ 代表数组， [I 就相当于 int[]</li>
<li>对象用 [L+ 类名表示</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h2><ul>
<li>jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。</li>
<li><p>在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析</p>
</li>
<li><p>命令格式</p>
<ul>
<li>jhat [dump file]</li>
</ul>
</li>
</ul>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><ul>
<li>jstack用于生成java虚拟机当前时刻的线程快照 </li>
<li><p>命令格式</p>
<ul>
<li>jstack [ option ] pid</li>
<li>jstack [ option ] executable core</li>
<li>jstack [ option ] [server-id@]remote-hostname-or-IP</li>
<li>option参数：</li>
<li>-F : 当正常输出请求不被响应时，强制输出线程堆栈</li>
<li>-l : 除堆栈外，显示关于锁的附加信息</li>
<li>-m : 如果调用到本地方法的话，可以显示C/C++的堆栈</li>
</ul>
</li>
<li><p>示例 输出文件：jstack -l 17063 &gt;1.txt</p>
</li>
<li><p>线程dump的分析工具</p>
<ul>
<li>IBM Thread and Monitor Dump Analyze for Java 一个小巧的Jar包，能方便的按状态，线程名称，线程停留的函数排序，快速浏览。</li>
<li><a href="http://spotify.github.io/threaddump-analyzer" target="_blank" rel="noopener">http://spotify.github.io/threaddump-analyzer</a> Spotify提供的Web版在线分析工具，可以将锁或条件相关联的线程聚合到一起</li>
</ul>
</li>
</ul>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><ul>
<li>jinfo(JVM Configuration info)这个命令作用是实时查看和调整虚拟机运行参数。</li>
<li>之前的jps -v口令只能查看到显示指定的参数，如果想要查看未被显示指定的参数的值就要使用jinfo口令</li>
<li>命令格式<ul>
<li>jinfo [option] [args] LVMID</li>
<li>option参数：</li>
<li>-flag : 输出指定args参数的值</li>
<li>-flags : 不需要args参数，输出所有JVM参数的值</li>
<li>-sysprops : 输出系统属性，等同于System.getProperties()</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/07/03/jvm-jvm类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/07/03/jvm-jvm类加载机制/" class="post-title-link" itemprop="url">jvm类加载机制</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-07-03 11:10:34" itemprop="dateCreated datePublished" datetime="2018-07-03T11:10:34+08:00">2018-07-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-22 15:45:09" itemprop="dateModified" datetime="2019-04-22T15:45:09+08:00">2019-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类加载器过程"><a href="#类加载器过程" class="headerlink" title="类加载器过程"></a>类加载器过程</h2><ul>
<li>从类被加载到虚拟机内存中开始，到卸御出内存为止，它的整个生命周期分为7个阶段，加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸御(Unloading)。其中验证、准备、解析三个部分统称为连接<br><img src="/2018/07/03/jvm-jvm类加载机制/load1.png" alt="classLoad" title="Optional title"></li>
</ul>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><ul>
<li>在加载阶段，虚拟机主要完成三件事情：<ul>
<li>通过一个类的全限定名（比如 com.danny.framework.t）来获取定义该类的二进制流</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为程序访问方法区中这个类的外部接口</li>
</ul>
</li>
</ul>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>验证的目的是为了确保 class 文件的字节流包含的内容符合虚拟机的要求，且不会危害虚拟机的安全</li>
<li>文件格式验证：主要验证 class 文件中二进制字节流的格式，比如魔数是否已 0xCAFEBABY 开头、版本号是否正确等</li>
<li>元数据验证：主要对字节码描述的信息进行语义分析，保证其符合 Java 语言规范，比如验证这个类是否有父类（java.lang.Object 除外），如果这个类不是抽象类，是否实现了父类或接口中没有实现的方法，等等</li>
<li>字节码验证：字节码验证更为高级，通过数据流和控制流分析，确保程序是合法的、符合逻辑的</li>
<li>符号引用验证：对类自身以外的信息进行匹配性校验，举个栗子，比如通过类的全限定名能否找到对应类、在类中能否找到字段名 / 方法名对应的字段 / 方法，如果符号引用验证失败，将抛出异常</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul>
<li>正式为【类变量】分配内存并设置类变量【初始值】，这些变量所使用的内存都分配在方法区。注意分配内存的对象是“类变量”而不是实例变量，而且为其分配的是“初始值”，一般数值类型的初始值都为0，char类型的初始值为’\u0000’（常量池中一个表示Nul的字符串），boolean类型初始值为false，引用类型初始值为null</li>
<li>但是加上final关键字比如public static final int value=123;在准备阶段会初始化value的值为123； </li>
</ul>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><ul>
<li>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程<ul>
<li>符号引用：简单的理解就是字符串，比如引用一个类，java.util.ArrayList 这就是一个符号引用，字符串引用的对象不一定被加载</li>
<li>直接引用：指针或者地址偏移量。引用对象一定在内存（已经加载）</li>
</ul>
</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul>
<li><p>在准备阶段，已经为类变量赋了初始值，在初始化阶段，则根据程序员通过程序定制的主观计划去初始化类变量的和其他资源，也可以从另一个角度来理解：初始化阶段是执行类构造器 <clinit>() 方法的过程，那 <clinit>() 到底是什么呢？</clinit></clinit></p>
</li>
<li><p>在准备阶段，已经为类变量赋了初始值，在初始化阶段，则根据程序员通过程序定制的主观计划去初始化类变量的和其他资源，也可以从另一个角度来理解：初始化阶段是执行类构造器 <clinit>() 方法的过程，那 <clinit>() 到底是什么呢？</clinit></clinit></p>
</li>
<li><p>下面看段代码来理解下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class Parent &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Parent-静态代码块执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Parent() &#123;</span><br><span class="line">        System.out.println(&quot;Parent-构造方法执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Parent-非静态代码块执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Child extends Parent&#123;</span><br><span class="line">    private static int staticValue = 123;</span><br><span class="line">    private int noStaticValue=456;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Child-静态代码块执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Child() &#123;</span><br><span class="line">        System.out.println(&quot;Child-构造方法执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;Child-非静态代码块执行&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Child child = new Child();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>看下面的运行结果之前可以先猜测一下结果是什么，运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Parent-静态代码块执行</span><br><span class="line">Child-静态代码块执行</span><br><span class="line">Parent-非静态代码块执行</span><br><span class="line">Parent-构造方法执行</span><br><span class="line">Child-非静态代码块执行</span><br><span class="line">Child-构造方法执行</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>上面的例子中可以看到一个类从加载到实例化的过程中，静态代码块、构造方法、非静态代码块的加载顺序。无法看到静态变量和非静态变量初始化的时间，静态变量的初始化和静态代码块的执行都是在类的初始化阶段 （<clinit>()） 完成，非静态变量和非静态代码块都是在实例的初始化阶段 （<init>()） 完成</init></clinit></li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类加载器的作用"><a href="#类加载器的作用" class="headerlink" title="类加载器的作用"></a>类加载器的作用</h3><ul>
<li><p>加载 class：类加载的加载阶段的第一个步骤，就是通过类加载器来完成的，类加载器的主要任务就是 “ 通过一个类的全限定名来获取描述此类的二进制字节流 ”，在这里，类加载器加载的二进制流并不一定要从 class 文件中获取，还可以从其他格式如zip文件中读取、从网络或数据库中读取、运行时动态生成、由其他文件生成（比如 jsp 生成 class 类文件）等</p>
</li>
<li><p>从程序员的角度来看，类加载器动态加载class文件到虚拟机中，并生成一个 java.lang.Class 实例，每个实例都代表一个 java 类，可以根据该实例得到该类的信息，还可以通过newInstance()方法生成该类的一个对象</p>
</li>
<li><p>确定类的唯一性：类加载器除了有加载类的作用，还有一个举足轻重的作用，对于每一个类，都需要由加载它的加载器和这个类本身共同确立这个类在 Java 虚拟机中的唯一性。也就是说，两个相同的类，只有是在同一个加载器加载的情况下才 “ 相等 ”，这里的 “ 相等 ” 是指代表类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括 instanceof 关键字对对象所属关系的判定结果</p>
</li>
</ul>
<h3 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h3><ul>
<li><p>以开发人员的角度来看，类加载器分为如下几种：启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）、应用程序类加载器（Application ClassLoader）和自定义类加载器（User ClassLoader），其中启动类加载器属于 JVM 的一部分，其他类加载器都用 java 实现，并且最终都继承自 java.lang.ClassLoader</p>
</li>
<li><p>启动类加载器（Bootstrap ClassLoader）是由 C/C++ 编译而来的，看不到源码，所以在 java.lang.ClassLoader 源码中看到的 Bootstrap ClassLoader 的定义是 native 的 private native Class findBootstrapClass(String name);。启动类加载器主要负责加载 JAVA_HOME\lib 目录或者被 -Xbootclasspath 参数指定目录中的部分类，具体加载哪些类可以通过 System.getProperty(“sun.boot.class.path”) 来查看</p>
</li>
<li><p>扩展类加载器（Extension ClassLoader）由 sun.misc.Launcher.ExtClassLoader 实现，负责加载 JAVA_HOME\lib\ext 目录或者被 java.ext.dirs 系统变量指定的路径中的所有类库，可以用通过 System.getProperty(“java.ext.dirs”) 来查看具体都加载哪些类</p>
</li>
<li><p>应用程序类加载器（Application ClassLoader）由 sun.misc.Launcher.AppClassLoader 实现，负责加载用户类路径（我们通常指定的 classpath）上的类，如果程序中没有自定义类加载器，应用程序类加载器就是程序默认的类加载器</p>
</li>
<li><p>自定义类加载器（User ClassLoader），JVM 提供的类加载器只能加载指定目录的类（jar 和 class），如果我们想从其他地方甚至网络上获取 class 文件，就需要自定义类加载器来实现，自定义类加载器主要都是通过继承 ClassLoader 或者它的子类来实现，但无论是通过继承 ClassLoader 还是它的子类，最终自定义类加载器的父加载器都是应用程序类加载器，因为不管调用哪个父类加载器，创建的对象都必须最终调用 java.lang.ClassLoader.getSystemClassLoader() 作为父加载器，getSystemClassLoader() 方法的返回值是 sun.misc.Launcher.AppClassLoader 即应用程序类加载器</p>
</li>
</ul>
<h3 id="ClassLoader-与双亲委派模型"><a href="#ClassLoader-与双亲委派模型" class="headerlink" title="ClassLoader 与双亲委派模型"></a>ClassLoader 与双亲委派模型</h3><ul>
<li><p>下面看一下类加载器 java.lang.ClassLoader 中的核心逻辑 loadClass() 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">        throws ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">            // 检查该类是否已经加载过</span><br><span class="line">            Class c = findLoadedClass(name);</span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                long t0 = System.nanoTime();</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (parent != null) &#123;//如果父加载器不为空，就用父加载器加载类</span><br><span class="line">                        c = parent.loadClass(name, false);</span><br><span class="line">                    &#125; else &#123;//如果父加载器为空，就用启动类加载器加载类</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                if (c == null) &#123;//如果上面用父加载器还没加载到类，就自己尝试加载</span><br><span class="line">                    long t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这段代码的主要意思就是当一个类加载器加载类的时候，如果有父加载器就先尝试让父加载器加载，如果父加载器还有父加载器就一直往上抛，一直把类加载的任务交给启动类加载器，然后启动类加载器如果加载不到类就会抛出 ClassNotFoundException 异常，之后把类加载的任务往下抛，如下图：<br><img src="/2018/07/03/jvm-jvm类加载机制/ClassLoad.png" alt="classLoad" title="Optional title"></p>
</li>
<li><p>通过上图的类加载过程，就引出了一个比较重要的概念——双亲委派模型，如下图展示的层次关系，双亲委派模型要求除了顶层的启动类加载器之外，其他的类加载器都应该有一个父类加载器，但是这种父子关系并不是继承关系，而是像上面代码所示的组合关系<br><img src="/2018/07/03/jvm-jvm类加载机制/ClassLoad1.png" alt="classLoad" title="Optional title"></p>
</li>
<li><p>双亲委派模型的工作过程是，如果一个类加载器收到了类加载的请求，它首先不会加载类，而是把这个请求委派给它上一层的父加载器，每层都如此，所以最终请求会传到启动类加载器，然后从启动类加载器开始尝试加载类，如果加载不到（要加载的类不在当前类加载器的加载范围），就让它的子类尝试加载，每层都是如此</p>
</li>
<li><p>那么双亲委派模型有什么好处呢？最大的好处就是它让 Java 中的类跟类加载器一样有了 “ 优先级 ”。前面说到了对于每一个类，都需要由加载它的加载器和这个类本身共同确立这个类在 Java 虚拟机中的唯一性，比如 java.lang.Object 类（存放在 JAVA_HOME\lib\rt.jar 中），如果用户自己写了一个 java.lang.Object 类并且由自定义类加载器加载，那么在程序中是不是就是两个类？所以双亲委派模型对保证 Java 稳定运行至关重要</p>
</li>
</ul>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>   <img src="/2018/07/03/jvm-jvm类加载机制/load2.png" alt="classLoad" title="Optional title"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/29/jvm-jvm性能调优/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/29/jvm-jvm性能调优/" class="post-title-link" itemprop="url">jvm性能调优</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-29 15:21:45" itemprop="dateCreated datePublished" datetime="2018-06-29T15:21:45+08:00">2018-06-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-22 15:44:26" itemprop="dateModified" datetime="2019-04-22T15:44:26+08:00">2019-04-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>JVM 调优目标：使用较小的内存占用来获得较高的吞吐量或者较低的延迟</li>
<li>程序在上线前的测试或运行中有时会出现一些大大小小的 JVM 问题，比如 cpu load 过高、请求延迟、tps 降低等，甚至出现内存泄漏（每次垃圾收集使用的时间越来越长，垃圾收集频率越来越高，每次垃圾收集清理掉的垃圾数据越来越少）、内存溢出导致系统崩溃，因此需要对 JVM 进行调优，使得程序在正常运行的前提下，获得更高的用户体验和运行效率</li>
<li><p>这里有几个比较重要的指标：</p>
<ul>
<li><p>内存占用：程序正常运行需要的内存大小。</p>
</li>
<li><p>延迟：由于垃圾收集而引起的程序停顿时间。</p>
</li>
<li><p>吞吐量：用户程序运行时间占用户程序和垃圾收集占用总时间的比值</p>
</li>
</ul>
</li>
<li>当然，和 CAP 原则一样，同时满足一个程序内存占用小、延迟低、高吞吐量是不可能的，程序的目标不同，调优时所考虑的方向也不同，在调优之前，必须要结合实际场景，有明确的的优化目标，找到性能瓶颈，对瓶颈有针对性的优化，最后进行测试，通过各种监控工具确认调优后的结果是否符合目标</li>
</ul>
<h2 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h2><ul>
<li><p>调优可以依赖、参考的数据有系统运行日志、堆栈错误信息、gc 日志、线程快照、堆转储快照等</p>
<ul>
<li>系统运行日志：系统运行日志就是在程序代码中打印出的日志，描述了代码级别的系统运行轨迹（执行的方法、入参、返回值等），一般系统出现问题，系统运行日志是首先要查看的日志</li>
<li>堆栈错误信息：当系统出现异常后，可以根据堆栈信息初步定位问题所在，比如根据 java.lang.OutOfMemoryError: Java heap space 可以判断是堆内存溢出；根据 java.lang.StackOverflowError 可以判断是栈溢出；根据 java.lang.OutOfMemoryError: PermGen space 可以判断是方法区溢出等</li>
<li>GC 日志：程序启动时用 -XX:+PrintGCDetails 和 -Xloggc:/data/jvm/gc.log 可以在程序运行时把 gc 的详细过程记录下来，或者直接配置 -verbose:gc 参数把 gc 日志打印到控制台，通过记录的 gc 日志可以分析每块内存区域 gc 的频率、时间等，从而发现问题，进行有针对性的优化</li>
<li><p>比如如下一段 GC 日志：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2018-08-02T14:39:11.560-0800: 10.171: [GC [PSYoungGen: 30128K-&gt;4091K(30208K)] 51092K-&gt;50790K(98816K), 0.0140970 secs] [Times: user=0.02 sys=0.03, real=0.01 secs] </span><br><span class="line">2018-08-02T14:39:11.574-0800: 10.185: [Full GC [PSYoungGen: 4091K-&gt;0K(30208K)] [ParOldGen: 46698K-&gt;50669K(68608K)] 50790K-&gt;50669K(98816K) [PSPermGen: 2635K-&gt;2634K(21504K)], 0.0160030 secs] [Times: user=0.03 sys=0.00, real=0.02 secs] </span><br><span class="line">2018-08-02T14:39:14.045-0800: 12.656: [GC [PSYoungGen: 14097K-&gt;4064K(30208K)] 64766K-&gt;64536K(98816K), 0.0117690 secs] [Times: user=0.02 sys=0.01, real=0.01 secs] </span><br><span class="line">2018-08-02T14:39:14.057-0800: 12.668: [Full GC [PSYoungGen: 4064K-&gt;0K(30208K)] [ParOldGen: 60471K-&gt;401K(68608K)] 64536K-&gt;401K(98816K) [PSPermGen: 2634K-&gt;2634K(21504K)], 0.0102020 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上面一共是 4 条 GC 日志，来看第一行日志，2018-08-02T14:39:11.560-0800 是精确到了毫秒级别的 UTC 通用标准时间格式，配置了 -XX:+PrintGCDateStamps 这个参数可以跟随gc日志打印出这种时间戳，10.171是从 JVM 启动到发生 gc 经过的秒数。第一行日志正文开头的 [GC 说明这次 GC 没有发生 Stop-The-World（用户线程停顿），第二行日志正文开头的 [Full GC 说明这次 GC 发生了 Stop-The-World，所以说，[GC 和 [Full GC 跟新生代和老年代没关系，和垃圾收集器的类型有关系，如果直接调用 System.gc()，将显示 [Full GC(System)</p>
</li>
<li><p>接下来的 [PSYoungGen 、 [ParOldGen 表示 GC 发生的区域，具体显示什么名字也跟垃圾收集器有关，比如这里的 [PSYoungGen 表示 Parallel Scavenge 收集器，[ParOldGen 表示 Serial Old 收集器，此外，Serial 收集器显示 [DefNew，ParNew 收集器显示 [ParNew 等</p>
</li>
<li><p>再往后的 30128K-&gt;4091K(30208K) 表示进行了这次 gc 后，该区域的内存使用空间由 30128K 减小到 4091K，总内存大小为 30208K</p>
</li>
<li><p>每个区域 gc 描述后面的 51092K-&gt;50790K(98816K), 0.0140970 secs 进行了这次垃圾收集后，整个堆内存的内存使用空间由 51092K 减小到 50790K，整个堆内存总空间为 98816K，gc 耗时 0.0140970秒</p>
</li>
</ul>
</li>
<li><p>线程快照：顾名思义，根据线程快照可以看到线程在某一时刻的状态，当系统中可能存在请求超时、死循环、死锁等情况是，可以根据线程快照来进一步确定问题。通过执行虚拟机自带的“jstack pid”命令，可以dump出当前进程中线程的快照信息，更详细的使用和分析网上有很多例，这篇文章写到这里已经很长了就不过多叙述了，贴一篇博客供参考： <a href="http://www.cnblogs.com/kongzhongqijing/articles/3630264.html" target="_blank" rel="noopener">http://www.cnblogs.com/kongzhongqijing/articles/3630264.html</a></p>
</li>
<li><p>堆转储快照：程序启动时可以使用 -XX:+HeapDumpOnOutOfMemory 和 -XX:HeapDumpPath=/data/jvm/dumpfile.hprof，当程序发生内存溢出时，把当时的内存快照以文件形式进行转储（也可以直接用 jmap 命令转储程序运行时任意时刻的内存快照），事后对当时的内存使用情况进行分析</p>
</li>
</ul>
</li>
</ul>
<h2 id="jvm自带调优工具说明"><a href="#jvm自带调优工具说明" class="headerlink" title="jvm自带调优工具说明"></a>jvm自带调优工具说明</h2><ul>
<li><p>用 jps（JVM process Status）可以查看虚拟机启动的所有进程、执行主类的全名、JVM启动参数，比如当执行了 JPSTest 类中的 main 方法后（main 方法持续执行），执行 jps -l可看到下面的JPSTest类的 pid 为 31354，加上 -v 参数还可以看到JVM启动参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3265 </span><br><span class="line">32914 sun.tools.jps.Jps</span><br><span class="line">31353 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">31354 com.danny.test.code.jvm.JPSTest</span><br><span class="line">380</span><br></pre></td></tr></table></figure>
</li>
<li><p>用jstat（JVM Statistics Monitoring Tool）监视虚拟机信息 jstat -gc pid 500 10：每 500 毫秒打印一次 Java 堆状况（各个区的容量、使用容量、gc 时间等信息），打印 10 次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line">11264.0 11264.0 11202.7  0.0   11776.0   1154.3   68608.0    36238.7     -      -      -      -        14    0.077   7      0.049    0.126</span><br><span class="line">11264.0 11264.0 11202.7  0.0   11776.0   4037.0   68608.0    36238.7     -      -      -      -        14    0.077   7      0.049    0.126</span><br><span class="line">11264.0 11264.0 11202.7  0.0   11776.0   6604.5   68608.0    36238.7     -      -      -      -        14    0.077   7      0.049    0.126</span><br><span class="line">11264.0 11264.0 11202.7  0.0   11776.0   9487.2   68608.0    36238.7     -      -      -      -        14    0.077   7      0.049    0.126</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0   258.1    68608.0    58983.4     -      -      -      -        15    0.082   8      0.059    0.141</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0   3076.8   68608.0    58983.4     -      -      -      -        15    0.082   8      0.059    0.141</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0    0.0     68608.0     390.0      -      -      -      -        16    0.084   9      0.066    0.149</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0    0.0     68608.0     390.0      -      -      -      -        16    0.084   9      0.066    0.149</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0   258.1    68608.0     390.0      -      -      -      -        16    0.084   9      0.066    0.149</span><br><span class="line">11264.0 11264.0  0.0    0.0   11776.0   3012.8   68608.0     390.0      -      -      -      -        16    0.084   9      0.066    0.149</span><br></pre></td></tr></table></figure>
</li>
<li><p>jstat 还可以以其他角度监视各区内存大小、监视类装载信息等，具体可以 google jstat 的详细用法</p>
</li>
<li><p>用 jmap（Memory Map for Java）查看堆内存信息 执行 jmap -histo pid 可以打印出当前堆中所有每个类的实例数量和内存占用，如下，class name 是每个类的类名（[B 是 byte 类型，[C是 char 类型，[I 是 int 类型），bytes 是这个类的所有示例占用内存大小，instances 是这个类的实例数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">num     #instances         #bytes  class name</span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          2291       29274080  [B</span><br><span class="line">   2:         15252        1961040  &lt;methodKlass&gt;</span><br><span class="line">   3:         15252        1871400  &lt;constMethodKlass&gt;</span><br><span class="line">   4:         18038         721520  java.util.TreeMap$Entry</span><br><span class="line">   5:          6182         530088  [C</span><br><span class="line">   6:         11391         273384  java.lang.Long</span><br><span class="line">   7:          5576         267648  java.util.TreeMap</span><br><span class="line">   8:            50         155872  [I</span><br><span class="line">   9:          6124         146976  java.lang.String</span><br><span class="line">  10:          3330         133200  java.util.LinkedHashMap$Entry</span><br><span class="line">  11:          5544         133056  javax.management.openmbean.CompositeDataSupport</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 jmap -dump 可以转储堆内存快照到指定文件，比如执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=/data/jvm/dumpfile_jmap.hprof 3361</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>利用 jconsole、jvisualvm 分析内存信息（各个区如 Eden、Survivor、Old 等内存变化情况），如果查看的是远程服务器的 JVM，程序启动需要加上如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;-Dcom.sun.management.jmxremote=true&quot; </span><br><span class="line">&quot;-Djava.rmi.server.hostname=12.34.56.78&quot; </span><br><span class="line">&quot;-Dcom.sun.management.jmxremote.port=18181&quot; </span><br><span class="line">&quot;-Dcom.sun.management.jmxremote.authenticate=false&quot; </span><br><span class="line">&quot;-Dcom.sun.management.jmxremote.ssl=false&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>下图是 jconsole 界面，概览选项可以观测堆内存使用量、线程数、类加载数和 CPU 占用率；内存选项可以查看堆中各个区域的内存使用量和左下角的详细描述（内存大小、GC 情况等）；线程选项可以查看当前 JVM 加载的线程，查看每个线程的堆栈信息，还可以检测死锁；VM 概要描述了虚拟机的各种详细参数<br><img src="/2018/06/29/jvm-jvm性能调优/jconsole.png" alt="jconsole" title="Optional title"></p>
</li>
<li><p>下图是 jvisualvm 的界面，功能比 jconsole 略丰富一些，不过大部分功能都需要安装插件。</p>
<p>概述跟 jconsole 的 VM 概要差不多，描述的是 jvm 的详细参数和程序启动参数；监视展示的和 jconsole 的概览界面差不多（CPU、堆/方法区、类加载、线程）；线程和 jconsole 的线程界面差不多；抽样器可以展示当前占用内存的类的排行榜及其实例的个数；Visual GC 可以更丰富地展示当前各个区域的内存占用大小及历史信息（下图）<br><img src="/2018/06/29/jvm-jvm性能调优/jvisualvm.png" alt="jvisualvm" title="Optional title"></p>
</li>
</ul>
</li>
</ul>
<h2 id="分析堆转储快照"><a href="#分析堆转储快照" class="headerlink" title="分析堆转储快照"></a>分析堆转储快照</h2><ul>
<li><p>前面说到配置了 -XX:+HeapDumpOnOutOfMemory 参数可以在程序发生内存溢出时 dump 出当前的内存快照，也可以用 jmap 命令随时 dump 出当时内存状态的快照信息，dump 的内存快照一般是以 .hprof 为后缀的二进制格式文件</p>
<ul>
<li><p>可以直接用 jhat（JVM Heap Analysis Tool） 命令来分析内存快照，它的本质实际上内嵌了一个微型的服务器，可以通过浏览器来分析对应的内存快照，比如执行 jhat -port 9810 -J-Xmx4G /data/jvm/dumpfile_jmap.hprof 表示以 9810 端口启动 jhat 内嵌的服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Reading from /Users/dannyhoo/data/jvm/dumpfile_jmap.hprof...</span><br><span class="line">Dump file created Fri Aug 03 15:48:27 CST 2018</span><br><span class="line">Snapshot read, resolving...</span><br><span class="line">Resolving 276472 objects...</span><br><span class="line">Chasing references, expect 55 dots.......................................................</span><br><span class="line">Eliminating duplicate references.......................................................</span><br><span class="line">Snapshot resolved.</span><br><span class="line">Started HTTP server on port 9810</span><br><span class="line">Server is ready.</span><br></pre></td></tr></table></figure>
</li>
<li><p>在控制台可以看到服务器启动了，访问 <a href="http://127.0.0.1:9810/" target="_blank" rel="noopener">http://127.0.0.1:9810/</a> 可以看到对快照中的每个类进行分析的结果（界面略 low），下图是我随便选择了一个类的信息，有这个类的父类，加载这个类的类加载器和占用的空间大小，下面还有这个类的每个实例（References）及其内存地址和大小，点进去会显示这个实例的一些成员变量等信息：<br> <img src="/2018/06/29/jvm-jvm性能调优/jhat.png" alt="jhat" title="Optional title"></p>
</li>
<li><p>jvisualvm 也可以分析内存快照，在 jvisualvm 菜单的 “ 文件 ” - “ 装入 ”，选择堆内存快照，快照中的信息就以图形界面展示出来了，如下，主要可以查看每个类占用的空间、实例的数量和实例的详情等：<br> <img src="/2018/06/29/jvm-jvm性能调优/jvisualvmDump.png" alt="jvisualvmDump" title="Optional title"></p>
</li>
</ul>
</li>
</ul>
<h2 id="JVM-调优经验"><a href="#JVM-调优经验" class="headerlink" title="JVM 调优经验"></a>JVM 调优经验</h2><ul>
<li><p>JVM 配置方面，一般情况可以先用默认配置（基本的一些初始参数可以保证一般的应用跑的比较稳定了），在测试中根据系统运行状况（会话并发情况、会话时间等），结合 gc 日志、内存监控、使用的垃圾收集器等进行合理的调整，当老年代内存过小时可能引起频繁 Full GC，当内存过大时 Full GC 时间会特别长</p>
</li>
<li><p>那么 JVM 的配置比如新生代、老年代应该配置多大最合适呢？答案是不一定，调优就是找答案的过程，物理内存一定的情况下，新生代设置越大，老年代就越小，Full GC 频率就越高，但 Full GC 时间越短；相反新生代设置越小，老年代就越大，Full GC 频率就越低，但每次 Full GC 消耗的时间越大</p>
</li>
<li><p>建议如下：</p>
<ul>
<li><p>-Xms 和 -Xmx 的值设置成相等，堆大小默认为 -Xms 指定的大小，默认空闲堆内存小于 40% 时，JVM 会扩大堆到 -Xmx 指定的大小；空闲堆内存大于 70% 时，JVM 会减小堆到 -Xms 指定的大小。如果在 Full GC 后满足不了内存需求会动态调整，这个阶段比较耗费资源</p>
</li>
<li><p>新生代尽量设置大一些，让对象在新生代多存活一段时间，每次 Minor GC 都要尽可能多的收集垃圾对象，防止或延迟对象进入老年代的机会，以减少应用程序发生 Full GC 的频率。</p>
</li>
<li><p>老年代如果使用 CMS 收集器，新生代可以不用太大，因为 CMS 的并行收集速度也很快，收集过程比较耗时的并发标记和并发清除阶段都可以与用户线程并发执行。</p>
</li>
<li><p>方法区大小的设置，1.6 之前的需要考虑系统运行时动态增加的常量、静态变量等，1.7 只要差不多能装下启动时和后期动态加载的类信息就行</p>
</li>
</ul>
</li>
<li><p>代码实现方面，性能出现问题比如程序等待、内存泄漏除了 JVM 配置可能存在问题，代码实现上也有很大关系：</p>
<ul>
<li><p>避免创建过大的对象及数组：过大的对象或数组在新生代没有足够空间容纳时会直接进入老年代，如果是短命的大对象，会提前出发 Full GC。</p>
</li>
<li><p>避免同时加载大量数据，如一次从数据库中取出大量数据，或者一次从 Excel 中读取大量记录，可以分批读取，用完尽快清空引用。</p>
</li>
<li><p>当集合中有对象的引用，这些对象使用完之后要尽快把集合中的引用清空，这些无用对象尽快回收避免进入老年代。</p>
</li>
<li><p>可以在合适的场景（如实现缓存）采用软引用、弱引用，比如用软引用来为 ObjectA 分配实例：SoftReference<objecta> objectA=new SoftReference<objecta>(); 在发生内存溢出前，会将 objectA 列入回收范围进行二次回收，如果这次回收还没有足够内存，才会抛出内存溢出的异常</objecta></objecta></p>
</li>
</ul>
</li>
<li><p>避免产生死循环，产生死循环后，循环体内可能重复产生大量实例，导致内存空间被迅速占满</p>
<ul>
<li>尽量避免长时间等待外部资源（数据库、网络、设备资源等）的情况，缩小对象的生命周期，避免进入老年代，如果不能及时返回结果可以适当采用异步处理的方式等</li>
</ul>
</li>
</ul>
<h2 id="常用JVM参数参考"><a href="#常用JVM参数参考" class="headerlink" title="常用JVM参数参考"></a>常用JVM参数参考</h2>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">参数	                            说明	                                                                                                          实例</span><br><span class="line"></span><br><span class="line">-Xms	                        初始堆大小，默认物理内存的1/64	                                                                                        -Xms512M</span><br><span class="line">-Xmx	                        最大堆大小，默认物理内存的1/4	                                                                                        -Xms2G</span><br><span class="line">-Xmn	                        新生代内存大小，官方推荐为整个堆的3/8	                                                                                        -Xmn512M</span><br><span class="line">-Xss	                        线程堆栈大小，jdk1.5及之后默认1M，之前默认256k	                                                                        -Xss512k</span><br><span class="line">-XX:NewRatio=n	            设置新生代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4	                                -XX:NewRatio=3</span><br><span class="line">-XX:SurvivorRatio=n	        年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如:8，表示Eden：Survivor=8:1:1，一个Survivor区占整个年轻代的1/8	      -XX:SurvivorRatio=8</span><br><span class="line">-XX:PermSize=n	            永久代初始值，默认为物理内存的1/64	                                                                                    -XX:PermSize=128M</span><br><span class="line">-XX:MaxPermSize=n	            永久代最大值，默认为物理内存的1/4	                                                                                    -XX:MaxPermSize=256M</span><br><span class="line">-verbose:class	            在控制台打印类加载信息	</span><br><span class="line">-verbose:gc	                在控制台打印垃圾回收日志	</span><br><span class="line">-XX:+PrintGC	                打印GC日志，内容简单	</span><br><span class="line">-XX:+PrintGCDetails	        打印GC日志，内容详细	</span><br><span class="line">-XX:+PrintGCDateStamps	    在GC日志中添加时间戳	</span><br><span class="line">-Xloggc:filename	            指定gc日志路径	                                                                                                    -Xloggc:/data/jvm/gc.log</span><br><span class="line">-XX:+UseSerialGC	            年轻代设置串行收集器Serial	</span><br><span class="line">-XX:+UseParallelGC	        年轻代设置并行收集器Parallel Scavenge	</span><br><span class="line">-XX:ParallelGCThreads=n	    设置Parallel Scavenge收集时使用的CPU数。并行收集线程数。	                                                                -XX:ParallelGCThreads=4</span><br><span class="line">-XX:MaxGCPauseMillis=n	    设置Parallel Scavenge回收的最大时间(毫秒)	                                                                            -XX:MaxGCPauseMillis=100</span><br><span class="line">-XX:GCTimeRatio=n	            设置Parallel Scavenge垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)                                                  	-XX:GCTimeRatio=19</span><br><span class="line">-XX:+UseParallelOldGC	        设置老年代为并行收集器ParallelOld收集器	</span><br><span class="line">-XX:+UseConcMarkSweepGC	    设置老年代并发收集器CMS	</span><br><span class="line">-XX:+CMSIncrementalMode	    设置CMS收集器为增量模式，适用于单CPU情况。</span><br></pre></td></tr></table></figure>
<h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p>   <img src="/2018/06/29/jvm-jvm性能调优/jvm.png" alt="性能调优" title="Optional title"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/27/jvm-jvm垃圾回收分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/27/jvm-jvm垃圾回收分析/" class="post-title-link" itemprop="url">jvm垃圾回收分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-27 20:50:04" itemprop="dateCreated datePublished" datetime="2018-06-27T20:50:04+08:00">2018-06-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-27 18:01:36" itemprop="dateModified" datetime="2019-04-27T18:01:36+08:00">2019-04-27</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h2><ul>
<li>垃圾回收，就是通过垃圾收集器把内存中没用的对象清理掉。垃圾回收涉及到的内容有：<ul>
<li>判断对象是否已死</li>
<li>选择垃圾收集算法</li>
<li>选择垃圾收集时间</li>
<li>选择适当的垃圾收集器（已死对象）</li>
</ul>
</li>
</ul>
<h3 id="判断对象是否已死"><a href="#判断对象是否已死" class="headerlink" title="判断对象是否已死"></a>判断对象是否已死</h3><ul>
<li><p>判断对象是否已死就是找出哪些对象是已经死掉的，以后不会再用到的，就像地上有废纸、饮料瓶和百元大钞，扫地前要先判断出地上废纸和饮料瓶是垃圾，百元大钞不是垃圾。<br>判断对象是否已死有引用计数算法和可达性分析算法</p>
<ul>
<li><p>引用计数算法</p>
<ul>
<li><p>给每一个对象添加一个引用计数器，每当有一个地方引用它时，计数器值加 1；每当有一个地方不再引用它时，计数器值减 1，这样只要计数器的值不为 0，<br>就说明还有地方引用它，它就不是无用的对象。如下图，对象 2 有 1 个引用，它的引用计数器值为 1，对象 1有两个地方引用，它的引用计数器值为 2<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm1.png" alt="jvm" title="Optional title"></p>
</li>
<li><p>这种方法看起来非常简单，但目前许多主流的虚拟机都没有选用这种算法来管理内存，原因就是当某些对象之间互相引用时，无法判断出这些对象是否已死，如下图，<br>对象 1 和对象 2 都没有被堆外的变量引用，而是被对方互相引用，这时他们虽然没有用处了，但是引用计数器的值仍然是 1，无法判断他们是死对象，垃圾回收器也就无法回收<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm2.png" alt="jvm" title="Optional title"></p>
</li>
</ul>
</li>
<li><p>可达性分析算法</p>
<ul>
<li>了解可达性分析算法之前先了解一个概念——GC Roots，垃圾收集的起点，<br>可以作为 GC Roots 的有虚拟机栈中本地变量表中引用的对象、方法区中静态属性引用的对象、方法区中常量引用的对象、本地方法栈中 JNI（Native 方法）引用的对象  </li>
<li>当一个对象到 GC Roots 没有任何引用链相连（GC Roots 到这个对象不可达）时，就说明此对象是不可用的，是死对象</li>
<li>如下图：object1、object2、object3、object4 和 GC Roots 之间有可达路径，<br>这些对象不会被回收，但 object5、object6、object7 到 GC Roots 之间没有可达路径，这些对象就被判了死刑<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm3.png" alt="jvm" title="Optional title"></li>
<li>上面被判了死刑的对象（object5、object6、object7）并不是必死无疑，还有挽救的余地。<br>进行可达性分析后对象和 GC Roots 之间没有引用链相连时，对象将会被进行一次标记，接着会判断如果对象没有覆盖 Object的finalize() 方法或者 finalize() 方法已经被虚拟机调用过<br>那么它们就会被行刑（清除）；如果对象覆盖了 finalize() 方法且还没有被调用，则会执行 finalize() 方法中的内容，所以在 finalize() 方法中如果重新与 GC Roots 引用链上的对象关联就可以拯救自己，<br>但是一般不建议这么做，周志明老师也建议大家完全可以忘掉这个方法</li>
</ul>
</li>
<li><p>方法区回收</p>
<ul>
<li><p>上面说的都是对堆内存中对象的判断，方法区中主要回收的是废弃的常量和无用的类。<br>判断常量是否废弃可以判断是否有地方引用这个常量，如果没有引用则为废弃的常量。</p>
</li>
<li><p>判断类是否废弃需要同时满足如下条件：</p>
<ul>
<li><p>该类所有的实例已经被回收（堆中不存在任何该类的实例）。</p>
</li>
<li><p>加载该类的 ClassLoader 已经被回收。</p>
</li>
<li><p>该类对应的 java.lang.Class 对象在任何地方没有被引用（无法通过反射访问该类的方法）。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>总结思维导图<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm003.png" alt="jvm" title="Optional title"></p>
</li>
</ul>
<h3 id="常用垃圾回收算法"><a href="#常用垃圾回收算法" class="headerlink" title="常用垃圾回收算法"></a>常用垃圾回收算法</h3><ul>
<li><p>常用的垃圾回收算法有三种：标记-清除算法、复制算法、标记-整理算法</p>
<ul>
<li>标记-清除算法：分为标记和清除两个阶段，首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象，如下图</li>
<li><p>缺点：标记和清除两个过程效率都不高；标记清除之后会产生大量不连续的内存碎片<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm4.png" alt="jvm" title="Optional title"></p>
</li>
<li><p>复制算法：把内存分为大小相等的两块，每次存储只用其中一块，当这一块用完了，就把存活的对象全部复制到另一块上，同时把使用过的这块内存空间全部清理掉，往复循环，如下图</p>
</li>
<li><p>缺点：实际可使用的内存空间缩小为原来的一半，比较适合<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm5.png" alt="jvm" title="Optional title"></p>
</li>
<li><p>标记-整理算法：先对可用的对象进行标记，然后所有被标记的对象向一段移动，最后清除可用对象边界以外的内存，如下图<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm6.png" alt="jvm" title="Optional title"></p>
</li>
<li><p>分代收集算法：把堆内存分为新生代和老年代，新生代又分为 Eden 区、From Survivor 和 To Survivor。一般新生代中的对象基本上都是朝生夕灭的，每次只有少量对象存活，因此采用复制算法，只需要复制那些少量存活的对象就可以完成垃圾收集；老年代中的对象存活率较高，就采用标记-清除和标记-整理算法来进行回收<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm7.png" alt="jvm" title="Optional title"></p>
</li>
<li><p>在这些区域的垃圾回收大概有如下几种情况:</p>
<ul>
<li>大多数情况下，新的对象都分配在Eden区，当 Eden 区没有空间进行分配时，将进行一次 Minor GC，清理 Eden 区中的无用对象。清理后，Eden 和 From Survivor 中的存活对象如果小于To Survivor 的可用空间则进入To Survivor，否则直接进入老年代）；Eden 和 From Survivor 中还存活且能够进入 To Survivor 的对象年龄增加 1 岁（虚拟机为每个对象定义了一个年龄计数器，每执行一次 Minor GC 年龄加 1），当存活对象的年龄到达一定程度（默认 15 岁）后进入老年代，可以通过 -XX:MaxTenuringThreshold 来设置年龄的值</li>
<li>当进行了 Minor GC 后，Eden 还不足以为新对象分配空间（那这个新对象肯定很大），新对象直接进入老年代</li>
<li>占 To Survivor 空间一半以上且年龄相等的对象，大于等于该年龄的对象直接进入老年代，比如 Survivor 空间是 10M，有几个年龄为 4 的对象占用总空间已经超过 5M，则年龄大于等于 4 的对象都直接进入老年代，不需要等到 MaxTenuringThreshold 指定的岁数</li>
<li>在进行 Minor GC 之前，会判断老年代最大连续可用空间是否大于新生代所有对象总空间，如果大于，说明 Minor GC 是安全的，否则会判断是否允许担保失败，如果允许，判断老年代最大连续可用空间是否大于历次晋升到老年代的对象的平均大小，如果大于，则执行 Minor GC，否则执行 Full GC</li>
<li>当在 java 代码里直接调用 System.gc() 时，会建议 JVM 进行 Full GC，但一般情况下都会触发 Full GC，一般不建议使用，尽量让虚拟机自己管理 GC 的策略</li>
<li>永久代（方法区）中用于存放类信息，jdk1.6 及之前的版本永久代中还存储常量、静态变量等，当永久代的空间不足时，也会触发 Full GC，如果经过 Full GC 还无法满足永久代存放新数据的需求，就会抛出永久代的内存溢出异常</li>
<li>大对象（需要大量连续内存的对象）例如很长的数组，会直接进入老年代，如果老年代没有足够的连续大空间来存放，则会进行 Full GC</li>
</ul>
</li>
</ul>
</li>
<li><p>总结思维导图<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm002.png" alt="jvm" title="Optional title"></p>
</li>
</ul>
<h3 id="选择垃圾收集的时间"><a href="#选择垃圾收集的时间" class="headerlink" title="选择垃圾收集的时间"></a>选择垃圾收集的时间</h3><ul>
<li><p>当程序运行时，各种数据、对象、线程、内存等都时刻在发生变化，当下达垃圾收集命令后就立刻进行收集吗？肯定不是。这里来了解两个概念：安全点（safepoint）和安全区（safe region）</p>
<ul>
<li><p>安全点</p>
<ul>
<li>从线程角度看，安全点可以理解为是在代码执行过程中的一些特殊位置，当线程执行到安全点的时候，说明虚拟机当前的状态是安全的，如果有需要，可以在这里暂停用户线程。当垃圾收集时，如果需要暂停当前的用户线程，但用户线程当时没在安全点上，则应该等待这些线程执行到安全点再暂停</li>
<li>举个例子，妈妈在扫地，儿子在吃西瓜（瓜皮会扔到地上），妈妈扫到儿子跟前时，儿子说：“妈妈等一下，让我吃完这块再扫。”儿子吃完这块西瓜把瓜皮扔到地上后就是一个安全点，妈妈可以继续扫地（垃圾收集器可以继续收集垃圾）。理论上，解释器的每条字节码的边界上都可以放一个安全点，实际上，安全点基本上以“是否具有让程序长时间执行的特征”为标准进行选定</li>
</ul>
</li>
<li><p>安全区</p>
<ul>
<li>安全点是相对于运行中的线程来说的，对于如sleep或blocked等状态的线程，收集器不会等待这些线程被分配CPU时间，这时候只要线程处于安全区中，就可以算是安全的。安全区就是在一段代码片段中，引用关系不会发生变化，可以看作是被扩展、拉长了的安全点</li>
<li>还以上面的例子说明，妈妈在扫地，儿子在吃西瓜（瓜皮会扔到地上），妈妈扫到儿子跟前时，儿子说：“妈妈你继续扫地吧，我还得吃10分钟呢！”儿子吃瓜的这段时间就是安全区，妈妈可以继续扫地（垃圾收集器可以继续收集垃圾）</li>
</ul>
</li>
</ul>
</li>
<li><p>垃圾回收过程<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm004.png" alt="jvm" title="Optional title"></p>
</li>
</ul>
<h3 id="常见垃圾收集器"><a href="#常见垃圾收集器" class="headerlink" title="常见垃圾收集器"></a>常见垃圾收集器</h3><ul>
<li>常见的垃圾收集器有如下几种：<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge。</li>
<li>老年代收集器：Serial Old、CMS、Parallel Old</li>
<li>堆内存垃圾收集器：G1</li>
</ul>
</li>
<li><p>每种垃圾收集器之间有连线，表示他们可以搭配使用<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm8.png" alt="jvm" title="Optional title"></p>
<ul>
<li><p>Serial 收集器</p>
<ul>
<li>Serial 是一款用于新生代的单线程收集器，采用复制算法进行垃圾收集。Serial 进行垃圾收集时，不仅只用一条线程执行垃圾收集工作，它在收集的同时，所有的用户线程必须暂停（Stop The World）</li>
<li>就比如妈妈在家打扫卫生的时候，肯定不会边打扫边让儿子往地上乱扔纸屑，否则一边制造垃圾，一遍清理垃圾，这活啥时候也干不完</li>
<li>如下是 Serial 收集器和 Serial Old 收集器结合进行垃圾收集的示意图，当用户线程都执行到安全点时，所有线程暂停执行，Serial 收集器以单线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm9.png" alt="jvm" title="Optional title"></li>
<li>适用场景：Client 模式（桌面应用）；单核服务器;可以用 -XX:+UserSerialGC 来选择 Serial 作为新生代收集器</li>
</ul>
</li>
<li><p>ParNew 收集器</p>
<ul>
<li>ParNew 就是一个 Serial 的多线程版本，其它与Serial并无区别。ParNew 在单核 CPU 环境并不会比 Serial 收集器达到更好的效果，它默认开启的收集线程数和 CPU 数量一致，可以通过 -XX:ParallelGCThreads 来设置垃圾收集的线程数</li>
<li>如下是 ParNew 收集器和 Serial Old 收集器结合进行垃圾收集的示意图，当用户线程都执行到安全点时，所有线程暂停执行，ParNew 收集器以多线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm10.png" alt="jvm" title="Optional title"></li>
<li>适用场景：多核服务器；与 CMS 收集器搭配使用。当使用 -XX:+UserConcMarkSweepGC 来选择 CMS 作为老年代收集器时，新生代收集器默认就是 ParNew，也可以用 -XX:+UseParNewGC 来指定使用 ParNew 作为新生代收集器</li>
</ul>
</li>
<li><p>Parallel Scavenge 收集器</p>
<ul>
<li>Parallel Scavenge 也是一款用于新生代的多线程收集器，与 ParNew 的不同之处是，ParNew 的目标是尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge 的目标是达到一个可控制的吞吐量</li>
<li><p>吞吐量就是 CPU 执行用户线程的的时间与 CPU 执行总时间的比值【吞吐量 = 运行用户代代码时间/（运行用户代码时间+垃圾收集时间）】，比如虚拟机一共运行了 100 分钟，其中垃圾收集花费了 1 分钟，那吞吐量就是 99% 。比如下面两个场景，垃圾收集器每 100 秒收集一次，每次停顿 10 秒，和垃圾收集器每 50 秒收集一次，每次停顿时间 7 秒，虽然后者每次停顿时间变短了，但是总体吞吐量变低了，CPU 总体利用率变低了</p>
<pre><code>收集频率                 每次停堆时间           吞吐量
每100秒收集一次              10秒               91%
每50秒收集一次                7秒               88%
</code></pre></li>
<li>可以通过 -XX:MaxGCPauseMillis 来设置收集器尽可能在多长时间内完成内存回收，可以通过 -XX:GCTimeRatio 来精确控制吞吐量 </li>
<li>如下是 Parallel 收集器和 Parallel Old 收集器结合进行垃圾收集的示意图，在新生代，当用户线程都执行到安全点时，所有线程暂停执行，ParNew 收集器以多线程，采用复制算法进行垃圾收集工作，收集完之后，用户线程继续开始执行；在老年代，当用户线程都执行到安全点时，所有线程暂停执行，Parallel Old 收集器以多线程，采用标记整理算法进行垃圾收集工作</li>
<li>-XX:+UseAdaptiveSizePolicy:这是一个开关参数，当这个参数打开后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGVPauseMillis参数或GCTimeRation参数给虚拟机设立一个优化目标<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm11.png" alt="jvm" title="Optional title"></li>
<li>适用场景：注重吞吐量，高效利用 CPU，需要高效运算且不需要太多交互。<br>可以使用 -XX:+UseParallelGC 来选择 Parallel Scavenge 作为新生代收集器，jdk7、jdk8 默认使用 Parallel Scavenge 作为新生代收集器</li>
</ul>
</li>
<li><p>Serial Old 收集器</p>
<ul>
<li>Serial Old 收集器是 Serial 的老年代版本，同样是一个单线程收集器，采用标记-整理算法</li>
<li>如下图是 Serial 收集器和 Serial Old 收集器结合进行垃圾收集的示意图：<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm12.png" alt="jvm" title="Optional title"></li>
<li>适用场景：Client 模式（桌面应用）；单核服务器；与 Parallel Scavenge 收集器搭配；作为 CMS 收集器的后备预案</li>
</ul>
</li>
<li><p>CMS(Concurrent Mark Sweep) 收集器</p>
<ul>
<li><p>CMS 收集器是一种以最短回收停顿时间为目标的收集器，以 “ 最短用户线程停顿时间 ” 著称。整个垃圾收集过程分为 4 个步骤：</p>
<ul>
<li>初始标记：标记一下 GC Roots 能直接关联到的对象，速度较快</li>
<li>并发标记：进行 GC Roots Tracing，标记出全部的垃圾对象，耗时较长</li>
<li>重新标记：修正并发标记阶段引用户程序继续运行而导致变化的对象的标记记录，耗时较短</li>
<li>并发清除：用标记-清除算法清除垃圾对象，耗时较长</li>
</ul>
</li>
<li><p>整个过程耗时最长的并发标记和并发清除都是和用户线程一起工作，所以从总体上来说，CMS 收集器垃圾收集可以看做是和用户线程并发执行的<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm13.png" alt="jvm" title="Optional title"></p>
</li>
<li>CMS 收集器也存在一些缺点：<ul>
<li>对 CPU 资源敏感：默认分配的垃圾收集线程数为（CPU 数+3）/4，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小</li>
<li>无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ” 的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集</li>
<li>因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC</li>
</ul>
</li>
<li>适用场景：重视服务器响应速度，要求系统停顿时间最短。可以使用 -XX:+UserConMarkSweepGC 来选择 CMS 作为老年代收集器</li>
</ul>
</li>
<li><p>Parallel Old 收集器</p>
<ul>
<li>Parallel Old 收集器是 Parallel Scavenge 的老年代版本，是一个多线程收集器，采用标记-整理算法。可以与 Parallel Scavenge 收集器搭配，可以充分利用多核 CPU 的计算能力<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm14.png" alt="jvm" title="Optional title"></li>
<li>适用场景：与Parallel Scavenge 收集器搭配使用；注重吞吐量。jdk7、jdk8 默认使用该收集器作为老年代收集器，使用 -XX:+UseParallelOldGC 来指定使用 Paralle Old 收集器</li>
</ul>
</li>
<li><p>G1 收集器</p>
<ul>
<li>G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 “ 化整为零 ” 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图：<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm15.png" alt="jvm" title="Optional title"></li>
<li>每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 -Xmx8g -Xms8g，则每个区域大小为 8g/2048=4M</li>
<li>为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据</li>
<li>G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率</li>
<li>如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似：<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm16.png" alt="jvm" title="Optional title"><br> 初始标记：标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行<ul>
<li>并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行</li>
<li>并发标记：从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行</li>
<li>筛选回收：筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程</li>
</ul>
</li>
<li>适用场景：要求尽可能可控 GC 停顿时间；内存占用较大的应用。可以用 -XX:+UseG1GC 使用 G1 收集器，jdk9 默认使用 G1 收集器 </li>
</ul>
</li>
<li><p>总结思维导图<br><img src="/2018/06/27/jvm-jvm垃圾回收分析/jvm001.png" alt="jvm" title="Optional title"></p>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/23/jvm-jvm内存溢出分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/23/jvm-jvm内存溢出分析/" class="post-title-link" itemprop="url">jvm内存溢出分析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-23 20:33:04" itemprop="dateCreated datePublished" datetime="2018-06-23T20:33:04+08:00">2018-06-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-20 14:24:45" itemprop="dateModified" datetime="2019-04-20T14:24:45+08:00">2019-04-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="堆内存溢出"><a href="#堆内存溢出" class="headerlink" title="堆内存溢出"></a>堆内存溢出</h2><ul>
<li><p>堆内存中主要存放对象、数组等，只要不断地创建这些对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾收集回收机制清除这些对象<br>当这些对象所占空间超过最大堆容量时，就会产生 OutOfMemoryError 的异常。堆内存异常示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置最大堆最小堆：-Xms20m -Xmx20m</span><br><span class="line"> * 运行时，不断在堆中创建OOMObject类的实例对象，且while执行结束之前，GC Roots(代码中的oomObjectList)到对象(每一个OOMObject对象)之间有可达路径，垃圾收集器就无法回收它们，最终导致内存溢出。</span><br><span class="line"> */</span><br><span class="line">public class HeapOOM &#123;</span><br><span class="line">    static class OOMObject &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;OOMObject&gt; oomObjectList = new ArrayList&lt;&gt;();</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            oomObjectList.add(new OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行后会报异常，在堆栈信息中可以看到</p>
<p>java.lang.OutOfMemoryError: Java heap space 的信息，说明在堆内存空间产生内存溢出的异常。</p>
<p>新产生的对象最初分配在新生代，新生代满后会进行一次 Minor GC，如果 Minor GC 后空间不足会把该对象和新生代满足条件的对象放入老年代，老年代空间不足时会进行 Full GC，之后如果空间还不足以存放新对象则抛出 OutOfMemoryError 异常。</p>
<p>常见原因：内存中加载的数据过多如一次从数据库中取出过多数据；集合对对象引用过多且使用完后没有清空；代码中存在死循环或循环产生过多重复对象；堆内存分配不合理；网络连接问题、数据库问题等</p>
</li>
</ul>
<h2 id="虚拟机栈-本地方法栈溢出"><a href="#虚拟机栈-本地方法栈溢出" class="headerlink" title="虚拟机栈/本地方法栈溢出"></a>虚拟机栈/本地方法栈溢出</h2><ul>
<li><p>StackOverflowError：当线程请求的栈的深度大于虚拟机所允许的最大深度，则抛出StackOverflowError，简单理解就是虚拟机栈中的栈帧数量过多（一个线程嵌套调用的方法数量过多）时，就会抛出StackOverflowError异常</p>
<ul>
<li>最常见就是方法无限递归调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置每个线程的栈大小：-Xss256k</span><br><span class="line"> * 运行时，不断调用doSomething()方法，main线程不断创建栈帧并入栈，导致栈的深度越来越大，最终导致栈溢出。</span><br><span class="line"> */</span><br><span class="line">public class StackSOF &#123;</span><br><span class="line">    private int stackLength=1;</span><br><span class="line">    public void doSomething()&#123;</span><br><span class="line">            stackLength++;</span><br><span class="line">            doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        StackSOF stackSOF=new StackSOF();</span><br><span class="line">        try &#123;</span><br><span class="line">            stackSOF.doSomething();</span><br><span class="line">        &#125;catch (Throwable e)&#123;//注意捕获的是Throwable</span><br><span class="line">            System.out.println(&quot;栈深度：&quot;+stackSOF.stackLength);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>上述代码执行后抛出：Exception in thread “Thread-0” java.lang.StackOverflowError 的异常</p>
</li>
<li><p>OutOfMemoryError：如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError</p>
<ul>
<li>我们可以这样理解，虚拟机中可以供栈占用的空间≈可用物理内存 - 最大堆内存 - 最大方法区内存，比如一台机器内存为 4G，系统和其他应用占用 2G，虚拟机可用的物理内存为 2G，最大堆内存为 1G，最大方法区内存为 512M<br>那可供栈占有的内存大约就是 512M，假如我们设置每个线程栈的大小为 1M，那虚拟机中最多可以创建 512个线程，超过 512个线程再创建就没有空间可以给栈了，就报 OutOfMemoryError 异常了</li>
</ul>
<p><img src="/2018/06/23/jvm-jvm内存溢出分析/oomStack.png" alt="oomStack" title="Optional title"></p>
<ul>
<li>栈上能够产生 OutOfMemoryError 的示例如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置每个线程的栈大小：-Xss2m</span><br><span class="line"> * 运行时，不断创建新的线程（且每个线程持续执行），每个线程对一个一个栈，最终没有多余的空间来为新的线程分配，导致OutOfMemoryError</span><br><span class="line"> */</span><br><span class="line">public class StackOOM &#123;</span><br><span class="line">    private static int threadNum = 0;</span><br><span class="line">    public void doSomething() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(100000000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final StackOOM stackOOM = new StackOOM();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                threadNum++;</span><br><span class="line">                Thread thread = new Thread(new Runnable() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void run() &#123;</span><br><span class="line">                        stackOOM.doSomething();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                thread.start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            System.out.println(&quot;目前活动线程数量：&quot; + threadNum);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>上述代码运行后会报异常，在堆栈信息中可以看到 java.lang.OutOfMemoryError: unable to create new native thread 的信息，无法创建新的线程，说明是在扩展栈的时候产生的内存溢出异常</p>
</li>
<li><p>总结：在线程较少的时候，某个线程请求深度过大，会报 StackOverflow 异常，解决这种问题可以适当加大栈的深度（增加栈空间大小），也就是把 -Xss 的值设置大一些，但一般情况下是代码问题的可能性较大；在虚拟机产生线程时，无法为该线程申请栈空间了，会报 OutOfMemoryError 异常，解决这种问题可以适当减小栈的深度，也就是把 -Xss 的值设置小一些，每个线程占用的空间小了，总空间一定就能容纳更多的线程，但是操作系统对一个进程的线程数有限制，经验值在 3000~5000 左右。<br>在 jdk1.5 之前 -Xss 默认是 256k，jdk1.5 之后默认是 1M，这个选项对系统硬性还是蛮大的，设置时要根据实际情况，谨慎操作</p>
</li>
</ul>
</li>
</ul>
<h2 id="方法区溢出"><a href="#方法区溢出" class="headerlink" title="方法区溢出"></a>方法区溢出</h2><ul>
<li>前面说到，方法区主要用于存储虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据，所以方法区溢出的原因就是没有足够的内存来存放这些数据</li>
<li><p>由于在 jdk1.6 之前字符串常量池是存在于方法区中的，所以基于 jdk1.6 之前的虚拟机，可以通过不断产生不一致的字符串（同时要保证和 GC Roots 之间保证有可达路径）来模拟方法区的 OutOfMemoryError 异常；但方法区还存储加载的类信息，<br>所以基于 jdk1.7 的虚拟机，可以通过动态不断创建大量的类来模拟方法区溢出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 设置方法区最大、最小空间：-XX:PermSize=10m -XX:MaxPermSize=10m</span><br><span class="line"> * 运行时，通过cglib不断创建JavaMethodAreaOOM的子类，方法区中类信息越来越多，最终没有可以为新的类分配的内存导致内存溢出</span><br><span class="line"> */</span><br><span class="line">public class JavaMethodAreaOOM &#123;</span><br><span class="line">    public static void main(final String[] args)&#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           while (true)&#123;</span><br><span class="line">               Enhancer enhancer=new Enhancer();</span><br><span class="line">               enhancer.setSuperclass(JavaMethodAreaOOM.class);</span><br><span class="line">               enhancer.setUseCache(false);</span><br><span class="line">               enhancer.setCallback(new MethodInterceptor() &#123;</span><br><span class="line">                   @Override</span><br><span class="line">                   public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                       return methodProxy.invokeSuper(o,objects);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               enhancer.create();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;catch (Throwable t)&#123;</span><br><span class="line">           t.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码运行后会报 java.lang.OutOfMemoryError: PermGen space 的异常，说明是在方法区出现了内存溢出的错误</p>
</li>
</ul>
<h2 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h2><ul>
<li><p>本机直接内存（DirectMemory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但 Java 中用到 NIO 相关操作时（比如 ByteBuffer 的 allocteDirect 方法申请的是本机直接内存），也可能会出现内存溢出的异常</p>
</li>
<li><p>DirectMemory容量可通过-XX:MaxDirectMemorySize指定，如果不指定，默认与java堆的最大值Xmx一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * VM Args: -xmx20M -XX:MaxDirectMemorySize=10M</span><br><span class="line"> */</span><br><span class="line">public class DirectMemoryOOM&#123;</span><br><span class="line"></span><br><span class="line">   private static final int _1MB = 1024 * 1024 ;</span><br><span class="line">   </span><br><span class="line">   public static void main(String [] args)throws Exception&#123;</span><br><span class="line">   </span><br><span class="line">      Field unsafeFild = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">      unsafeField.setAccessible(true);</span><br><span class="line">      Unsafe unsafe = (Unsafe) unsafeFileld.get(null);</span><br><span class="line">      while(true)&#123;</span><br><span class="line">         unsafe.allocateMemory(_1MB);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述代码运行后会报 java.lang.OutOfMemoryError的异常，说明是在直接内存出现了内存溢出的错误</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  <img src="/2018/06/23/jvm-jvm内存溢出分析/jvmStackTop.png" alt="jvmStackTop" title="Optional title"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/22/jvm-jvm内存区域解读/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/22/jvm-jvm内存区域解读/" class="post-title-link" itemprop="url">jvm内存区域解读</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-22 18:12:04" itemprop="dateCreated datePublished" datetime="2018-06-22T18:12:04+08:00">2018-06-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-20 12:22:39" itemprop="dateModified" datetime="2019-04-20T12:22:39+08:00">2019-04-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/jvm/" itemprop="url" rel="index"><span itemprop="name">jvm</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p>Java虚拟机在运行时，会把内存空间分为若干个区域，根据《Java虚拟机规范（Java SE 7 版）》的规定，<br>Java虚拟机所管理的内存区域分为如下部分：方法区、堆内存、虚拟机栈、本地方法栈、程序计数器</p>
<p><img src="/2018/06/22/jvm-jvm内存区域解读/jvmMemoryArea.png" alt="jvmMemoryArea" title="Optional title"></p>
</li>
</ul>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><ul>
<li><p>方法区主要用于存储虚拟机加载的类信息、常量、静态变量、以及编译器编译后的代码等数据。在JDK1.7及其之前，<br>方法区是堆的一个”逻辑部分”（一片连续的堆空间），但为了与堆做区分，方法区还有个名字叫“非堆”，也有人用“永久代”（HotSpot对方法区的实现方法）来表示方法区。</p>
</li>
<li><p>从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中,常量池除字符串常量池还有class常量池等），<br>这里只是把字符串常量池移到堆内存中；在jdk1.8中，方法区已经不存在，原方法区中存储的类信息、编译后的代码数据等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。<br>根据网上的资料结合自己的理解对jdk1.3~1.6、jdk1.7、jdk1.8中方法区的变迁画了张图如下（如有不合理的地方希望读者指出）：</p>
<p><img src="/2018/06/22/jvm-jvm内存区域解读/jdkversion.png" alt="jdk" title="Optional title"></p>
</li>
<li><p>去永久代的原因有:</p>
<ul>
<li>字符串存在永久代中，容易出现性能问题和内存溢出。</li>
<li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li>
<li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li>
</ul>
</li>
</ul>
<h2 id="堆内存"><a href="#堆内存" class="headerlink" title="堆内存"></a>堆内存</h2><ul>
<li>堆内存主要用于存放对象和数组，它是JVM管理的内存中最大的一块区域，堆内存和方法区都被所有线程共享，在虚拟机启动时创建。<br>在垃圾收集的层面上来看，由于现在收集器基本上都采用分代收集算法，因此堆还可以分为新生代（YoungGeneration）和老年代（OldGeneration），新生代还可以分为 Eden、From Survivor、To Survivor</li>
</ul>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><ul>
<li>程序计数器是一块非常小的内存空间，可以看做是当前线程执行字节码的行号指示器，每个线程都有一个独立的程序计数器，<br>因此程序计数器是线程私有的一块空间，此外，程序计数器是Java虚拟机规定的唯一不会发生内存溢出的区域</li>
</ul>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><ul>
<li>虚拟机栈也是每个线程私有的一块内存空间，它描述的是方法的内存模型，直接看下图所示：<br><img src="/2018/06/22/jvm-jvm内存区域解读/jvmStack.png" alt="jvmStack" title="Optional title"></li>
<li>虚拟机会为每个线程分配一个虚拟机栈，每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。<br>一个栈帧就对应 Java 代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，<br>每一个 Java 方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程</li>
</ul>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><ul>
<li>本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是 Java 方法，本地方法栈执行的是本地方法（Native Method）<br>其他基本上一致，在 HotSpot 中直接把本地方法栈和虚拟机栈合二为一，这里暂时不做过多叙述</li>
</ul>
<h2 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h2><ul>
<li>上面说到，jdk1.8 中，已经不存在永久代（方法区），替代它的一块空间叫做 “ 元空间 ”，和永久代类似，<br>都是 JVM 规范对方法区的实现，但是元空间并不在虚拟机中，而是使用本地内存，元空间的大小仅受本地内存限制，<br>但可以通过 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 来指定元空间的大小</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>   <img src="/2018/06/22/jvm-jvm内存区域解读/jvm.png" alt="jvm" title="Optional title"></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/12/nginx-nginx整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/12/nginx-nginx整理/" class="post-title-link" itemprop="url">nginx整理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-12 22:12:04" itemprop="dateCreated datePublished" datetime="2018-06-12T22:12:04+08:00">2018-06-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-20 12:06:04" itemprop="dateModified" datetime="2019-04-20T12:06:04+08:00">2019-04-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="内置预定义变量"><a href="#内置预定义变量" class="headerlink" title="内置预定义变量"></a>内置预定义变量</h2><ul>
<li><code>$args</code>：这个变量等于GET请求中的参数。例如foo=123&amp;bar=456，这个变量只能被修改</li>
<li><code>$host</code>：请求中的主机头(HOST)字段，如果请求中的主机头不可用或者空，则为处理请求的server名称(处理请求的server的server_name指令的值)。值为小写，不包含端口</li>
<li><code>$remote_addr</code>：客户端的IP地址</li>
<li><code>$remote_port</code>：客户端的端口</li>
<li><code>$request_uri</code>：这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI</li>
<li><code>$scheme</code>：所用的协议，比如http或者是https，比如<code>rewrite ^(.+)$ $scheme://example.com$1 redirect;</code></li>
<li><code>$server_addr</code>：服务器地址，在完成一次系统调用后可以确定这个值，如果要绕开系统调用，则必须在listen中指定地址并且使用bind参数</li>
<li><code>$server_name</code>：服务器名称</li>
<li><code>$server_port</code>：请求到达服务器的端口号</li>
<li><code>$server_protocol</code>：请求使用的协议，通常是HTTP/1.0或HTTP/1.1</li>
<li><code>$uri</code>：请求中的当前URI(不带请求参数，参数位于<code>$args</code>)，不同于浏览器传递的<code>$request_uri</code>的值，它可以通过内部重定向，或者使用index指令进行修改。不包含协议和主机名，例如<code>/foo/bar.html</code></li>
</ul>
          <!--noindex-->
          
            <div class="post-button text-center">
              <a class="btn" href="/2018/06/12/nginx-nginx整理/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          
          <!--/noindex-->
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/11/nginx-nginx安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/11/nginx-nginx安装/" class="post-title-link" itemprop="url">nginx安装</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-11 20:12:04" itemprop="dateCreated datePublished" datetime="2018-06-11T20:12:04+08:00">2018-06-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-20 12:06:22" itemprop="dateModified" datetime="2019-04-20T12:06:22+08:00">2019-04-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/nginx/" itemprop="url" rel="index"><span itemprop="name">nginx</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="官网下载-nginx"><a href="#官网下载-nginx" class="headerlink" title="官网下载 nginx"></a>官网下载 nginx</h2><ul>
<li>1 下载 Nginx，下载地址：<a href="http://nginx.org/download/nginx-1.6.2.tar.gz,并上传到服务器，或直接使用wget" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.6.2.tar.gz,并上传到服务器，或直接使用wget</a> </li>
</ul>
<h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><ul>
<li>1 解压安装包  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar zxvf nginx-1.6.2.tar.gz</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>2 进入解压目录</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd nginx-1.6.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 编译安装</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">命令：</span><br><span class="line">     ./configure --prefix=/usr/local/nginx</span><br><span class="line">      make &amp;&amp; make install</span><br><span class="line">错误：./configure: error: the HTTP rewrite module requires the PCRE library.如果出现以上错误</span><br><span class="line">      解决如下：</span><br><span class="line">              yum -y install pcre-devel openssl openssl-devel</span><br><span class="line">              然后重新执行上一步命令</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="安装完成"><a href="#安装完成" class="headerlink" title="安装完成"></a>安装完成</h2><ul>
<li><p>1 查看版本</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure>
</li>
<li><p>2 启动Nginx</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local//nginx/sbin/nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>3 Nginx其他命令</p>
<pre><code>/usr/local/nginx/sbin/nginx -s reload            # 重新载入配置文件
/usr/local/nginx/sbin/nginx -s reopen            # 重启 Nginx
/usr/local/nginx/sbin/nginx -s stop              # 停止 Nginx
</code></pre><h2 id="访问Nginx"><a href="#访问Nginx" class="headerlink" title="访问Nginx"></a>访问Nginx</h2></li>
<li><p>1 阿里云服务器默认80端口关闭，需要在控制台管理界面，左侧菜单 安全组–&gt;配置规则，添加80/80端口。即可访问</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mocwe.com/2018/06/05/spring-boot-EnableAutoConfiguration实战与原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rick Liu">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar-user.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="每天进步一小点">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/06/05/spring-boot-EnableAutoConfiguration实战与原理/" class="post-title-link" itemprop="url">EnableAutoConfiguration实战与原理</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-06-05 11:12:04" itemprop="dateCreated datePublished" datetime="2018-06-05T11:12:04+08:00">2018-06-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-04-19 17:03:57" itemprop="dateModified" datetime="2019-04-19T17:03:57+08:00">2019-04-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/spring-boot/" itemprop="url" rel="index"><span itemprop="name">spring boot</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>在 SpringBoot 项目中集成其他框架是非常简单的，如果需要添加 WebMvc，只需要引入对应的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>就可以了，这样就轻轻松松的把 WebMVC 给整合进来了，是不是超简单。就连 @EnableXX 注解都不需要，那是为什么呢？是时候来剖析其中的原理了。<br>SpringBoot 项目中通常是添加注解 @SpringBootApplication，这个注解集成了常用的几个注解：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootConfiguration，@EnableAutoConfiguration，@ComponentScan</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果只是单纯的启动 SpringBoot 项目的话，只需要添加 @SpringBootConfiguration 注解就可以了。这样项目是虽然可以正常启动与使用，但是就失去了 SpringBoot 给我们带来的便利性。SpringBoot 整合其他框架通常会有各种 AutoConfiguration，但是必须得添加 @EnableAutoConfiguration 注解才可以使用。这里来解析下：<br>在 SpringBoot 官方文档中，特别说明了 META-INF/spring.factories 目录的使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">43.1 Understanding auto-configured beans</span><br><span class="line">Under the hood, auto-configuration is implemented with standard @Configuration classes. Additional @Conditional annotations are used to constrain when the auto-configuration should apply. Usually auto-configuration classes use @ConditionalOnClass and @ConditionalOnMissingBean annotations. This ensures that auto-configuration only applies when relevant classes are found and when you have not declared your own @Configuration.</span><br><span class="line"></span><br><span class="line">You can browse the source code of spring-boot-autoconfigure to see the @Configuration classes that we provide (see the META-INF/spring.factories file).</span><br><span class="line"></span><br><span class="line">43.2 Locating auto-configuration candidates</span><br><span class="line">Spring Boot checks for the presence of a META-INF/spring.factories file within your published jar. The file should list your configuration classes under the EnableAutoConfiguration key.</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXAutoConfiguration,\</span><br><span class="line">com.mycorp.libx.autoconfigure.LibXWebAutoConfiguration</span><br><span class="line">You can use the @AutoConfigureAfter or @AutoConfigureBefore annotations if your configuration needs to be applied in a specific order. For example, if you provide web-specific configuration, your class may need to be applied after WebMvcAutoConfiguration.</span><br><span class="line"></span><br><span class="line">If you want to order certain auto-configurations that shouldn’t have any direct knowledge of each other, you can also use @AutoconfigureOrder. That annotation has the same semantic as the regular @Order annotation but provides a dedicated order for auto-configuration classes.</span><br></pre></td></tr></table></figure>
</li>
<li><p>大致意思是说 SpringBoot 会自动解析所有 jar 中的 META-INF/spring.factories 文件。其中大部分自动配置文件都放在了 spring-boot-autoconfigure 的 jar 中，可以根据自己的需要去看看。<br>如果需要指定自动配置类的顺序，可以使用 @AutoConfigureAfter @AutoConfigureBefore、@AutoconfigureOrder 进行设置顺序。</p>
<p>那么来解析下 @EnableAutoConfiguration 注解做了什么。</p>
</li>
</ul>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><ul>
<li><p>@EnableAutoConfiguration代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line">//略。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现这里使用了 @Import 注解，导入 EnableAutoConfigurationImportSelector 类。</p>
<p>@Import 可以将对应的 Bean 导入到 Spring 上下文中。如果类在工程中的话那么直接使用 @Configuration 注解即可，Spring 会自动识别的。但是如果在其他 jar 包或框架上，没有配置到自动扫描的目录中或者是没有添加 @Configuration 注解，那么就需要使用 @Import 将其导入到项目中来。</p>
<p>EnableAutoConfigurationImportSelector 继承了 AutoConfigurationImportSelector，实现了 isEnable 方法，当配置文件中配置 spring.boot.enableautoconfiguration=false 的时候，@EnableAutoConfiguration 功能为关闭状态，不进行其他自动逻辑处理。也就是所有的 EnableXX 框架都不能自动配置启动了。</p>
<p>ImportSelector 核心作用就是：将方法 selectImports 中返回的类数组导入到 Spring 上下文中。</p>
<p>AutoConfigurationImportSelector 间接的实现了 ImportSelector 接口，且实现为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">  //配置spring.boot.enableautoconfiguration=false的时候不导入任何bean</span><br><span class="line">    if (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        return NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader</span><br><span class="line">                .loadMetadata(this.beanClassLoader);</span><br><span class="line">        AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata,</span><br><span class="line">                attributes);</span><br><span class="line">        configurations = removeDuplicates(configurations);</span><br><span class="line">        configurations = sort(configurations, autoConfigurationMetadata);</span><br><span class="line">        Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">        checkExcludedClasses(configurations, exclusions);</span><br><span class="line">        configurations.removeAll(exclusions);</span><br><span class="line">        configurations = filter(configurations, autoConfigurationMetadata);</span><br><span class="line">        fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">        return configurations.toArray(new String[configurations.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    catch (IOException ex) &#123;</span><br><span class="line">        throw new IllegalStateException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上这部分代码就是自动配置的核心了，下面对以上的代码进行逐步分析：<br>AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader .loadMetadata(this.beanClassLoader);</p>
</li>
<li><p>这里读取了 META-INF/spring-autoconfigure-metadata.properties 配置文件，这个配置文件中配置了 SpringBoot 自动集成的各种 Enable 框架的执行条件，比如定义与其他 AutoConfiguration 框架的执行顺序，<br>需要哪些 Bean 在的时候才可以执行等。这里的功能就等价于 @AutoConfigureAfter @AutoConfigureBefore 注解的功能。<br>下面截取部分配置，感兴趣的可以到 spring-boot-autoconfig- 版本号 /META-INF/spring-autoconfigure-metadata.properties 文件中查看</p>
<p><img src="/2018/06/05/spring-boot-EnableAutoConfiguration实战与原理/EnableAutoConfiguration.png" alt="EnableAutoConfiguration" title="Optional title"></p>
</li>
<li><p>这里读取 META-INF/spring.factories 配置文件中对应 key：org.springframework.boot.autoconfigure.EnableAutoConfiguration 所对应的类。<br>源码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,</span><br><span class="line">        AnnotationAttributes attributes) &#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(</span><br><span class="line">            getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations,</span><br><span class="line">            &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span><br><span class="line">                    + &quot;are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  SpringFactoriesLoader.loadFactoryNames 方法中主要是加载 META-INF/spring.factories 文件，并且获取 key 为 EnableAutoConfiguration 类全名对应的属性值。感兴趣的可以继续跟入看看源码。</p>
<p>  AnnotationAttributes attributes = getAttributes(annotationMetadata);<br>  这里读取 @EnableAutoConfiguration 注解中配置的 exclude，excludeName 两个属性值。</p>
<p>  configurations = removeDuplicates(configurations);<br>  去除重复的引用，这里实现相当的简单，先将 list 转换有序的 set 对象，这样的话重复的类就被自动剔除了，然后再将 set 转换成 list。</p>
<p>  configurations = sort(configurations, autoConfigurationMetadata);<br>  顾名思义，这里是对所有的自动配置 Bean 进行排序，使用的规则就是在上面获取到的配置文件的 autoConfigurationMetadata。</p>
</li>
<li><p>sort 的实现为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  private List&lt;String&gt; sort(List&lt;String&gt; configurations,</span><br><span class="line">        AutoConfigurationMetadata autoConfigurationMetadata) throws IOException &#123;</span><br><span class="line">    configurations = new AutoConfigurationSorter(getMetadataReaderFactory(),</span><br><span class="line">            autoConfigurationMetadata).getInPriorityOrder(configurations);</span><br><span class="line">    return configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实际的排序功能是在 getInPriorityOrder 中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; getInPriorityOrder(Collection&lt;String&gt; classNames) &#123;</span><br><span class="line">    final AutoConfigurationClasses classes = new AutoConfigurationClasses(</span><br><span class="line">            this.metadataReaderFactory, this.autoConfigurationMetadata, classNames);</span><br><span class="line">    List&lt;String&gt; orderedClassNames = new ArrayList&lt;String&gt;(classNames);</span><br><span class="line">    // Initially sort alphabetically</span><br><span class="line">    Collections.sort(orderedClassNames);</span><br><span class="line">    // Then sort by order</span><br><span class="line">    Collections.sort(orderedClassNames, new Comparator&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public int compare(String o1, String o2) &#123;</span><br><span class="line">            int i1 = classes.get(o1).getOrder();</span><br><span class="line">            int i2 = classes.get(o2).getOrder();</span><br><span class="line">            return (i1 &lt; i2) ? -1 : (i1 &gt; i2) ? 1 : 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    // Then respect @AutoConfigureBefore @AutoConfigureAfter</span><br><span class="line">    orderedClassNames = sortByAnnotation(classes, orderedClassNames);</span><br><span class="line">    return orderedClassNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的实现还是比较清晰的，先通过类名自然排序，然后根据 Bean 配置的 Order 排序 （@AutoConfigureOrder 或在配置文件中指定），最后根据 @AutoConfigureBefore @AutoConfigureAfter 注解中配置（配置文件中指定）的顺序关系进行排序。通过以上步骤，就将所有 AutoConfiguration 的顺序指定 ok 了。</p>
<p>Set exclusions = getExclusions(annotationMetadata, attributes);<br>获取 EnableAutoConfiguration 注解中配置的 exclude，excludeName 与配置中配置的 spring.autoconfigure.exclude 对应的类。</p>
<p>checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions);<br>先对之前步骤获取到的需要剔除的类进行是否存在校验，如果在所有的 AutoConfiguration（configurations）中都不包含配置的类的话，那么说明配置有问题，直接抛出异常。如果都存在的话，那么从 configurations 去除需要排除的类。</p>
<p>configurations = filter(configurations, autoConfigurationMetadata);<br>进行数据过滤。这里会获取系统中所有的 AutoConfigurationImportFilter 对象，通过循环调用 AutoConfigurationImportFilter.match 方法筛选出不符合条件的 AutoConfiguration 类。这样流程过后剩下的 AutoConfiguration 类就是符合我们系统的要求了。</p>
<p>fireAutoConfigurationImportEvents(configurations, exclusions);<br>发送自动配置筛选完成事件（AutoConfigurationImportEvent），将筛选后的结果通知对应的（实现了 AutoConfigurationImportListener）的监听者，进行对应的操作。</p>
<p>通过以上步骤后，就筛选出了符合需要的自动配置的类。针对以上步骤整理出的流程图如下：</p>
<p> <img src="/2018/06/05/spring-boot-EnableAutoConfiguration实战与原理/EnableAutoFlow.png" alt="EnableAutoConfigurationFlow" title="Optional title"></p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>@EnableAutoConfiguration 会自动将工程中 META-INF/spring.factories 配置文件中 key 为 org.springframework.boot.autoconfigure.EnableAutoConfiguration 对应的所有类进行自动导入。<br>这也就是为什么 @EnableAutoConfiguration 是 SpringBoot 项目的标配注解了，如果没有导入这个注解所实现的功能，那么所有的自动配置功能将无法使用，也就失去了 SpringBoot 的方便性了。<br>如果需要配置自动配置类的加载顺序，可以在 META-INF/spring-autoconfigure-metadata.properties 进行配置。这里就可以解释为什么有的框架直接引入对应的 jar 就可以自动运行的原因（如 Web）。</li>
</ul>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul>
<li><p>有两个自动配置类 TestConfiguration，TestConfiguration2 代码基本一样。只在构造方法中打印出实例化后的类名和 init 信息，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class TestConfiguration &#123;</span><br><span class="line">private static Logger log = LoggerFactory.getLogger(TestConfiguration.class);</span><br><span class="line"></span><br><span class="line">public TestConfiguration() &#123;</span><br><span class="line">    log.info(&quot;=========&gt;TestConfiguration init!!!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后将这两个类配置到工程中的 META-INF/spring.factories 文件中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration,com.cml.chat.lesson.lesson5.TestConfiguration2</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认 Bean 的加载是按照类名的自然排序进行的，项目启动后输入的 log 为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration - =========&gt;TestConfiguration init!!!</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration2 - =========&gt;TestConfiguration2 init!!!</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时如果想要 TestConfiguration2 优先于 TestConfiguration 执行，比如 TestConfiguration 需要依赖 TestConfiguration2 做的操作。<br>那么这时候就可以在 META-INF/spring-autoconfigure-metadata.properties 添加配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#order config</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration=</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration2=</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration.AutoConfigureAfter=com.cml.chat.lesson.lesson5.TestConfiguration2</span><br></pre></td></tr></table></figure>
</li>
<li><p>项目启动后输入 log：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration2 - =========&gt;TestConfiguration2 init!!!</span><br><span class="line">com.cml.chat.lesson.lesson5.TestConfiguration - =========&gt;TestConfiguration init!!!</span><br></pre></td></tr></table></figure>
</li>
<li><p>TestConfiguration 在 TestConfiguration2 初始化之后了，这里可以完成注解对应的顺序功能和条件限制功能。</p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar-user.jpeg" alt="Rick Liu">
            
              <p class="site-author-name" itemprop="name">Rick Liu</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/ricklyh" title="GitHub &rarr; https://github.com/ricklyh" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:lyhuijavait@163.com" title="E-Mail &rarr; mailto:lyhuijavait@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://ife.baidu.com/" title="http://ife.baidu.com/" rel="noopener" target="_blank">百度前端技术学院</a>
                  </li>
                
              </ul>
            </div>
          

          
              <div class="links-of-blogroll motion-element links-of-blogroll-block">
                <div class="links-of-blogroll-title">
                  <!-- modify icon to fire by szw -->
                  <i class="fa fa-history fa-" aria-hidden="true"></i>
                  近期文章
                </div>
                <ul class="links-of-blogroll-list">
                  
                  
                    <li>
                      <a href="/2019/04/03/interview-面试问题总结/" title="面试问题总结" target="_blank">面试问题总结</a>
                    </li>
                  
                    <li>
                      <a href="/2019/04/03/zookeeper-Leader选举原理/" title="Leader选举原理" target="_blank">Leader选举原理</a>
                    </li>
                  
                    <li>
                      <a href="/2019/02/02/java-ThreadLocal原理分析/" title="ThreadLocal原理分析" target="_blank">ThreadLocal原理分析</a>
                    </li>
                  
                    <li>
                      <a href="/2018/11/14/distributed-高并发详解/" title="高并发详解" target="_blank">高并发详解</a>
                    </li>
                  
                    <li>
                      <a href="/2018/11/14/network-理解OSI七层模型/" title="理解OSI七层模型" target="_blank">理解OSI七层模型</a>
                    </li>
                  
                </ul>
              </div>
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rick Liu</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.0"></script>

  <script src="/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.0"></script>




  

  


  <script src="/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
